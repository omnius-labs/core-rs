use std::fmt::Write as _;

use crate::{config::*, error::*, parser::ast::*};

pub async fn generate(_sources: &[SourceConfig], _conf: &GeneratorConfig) -> Result<(), CodegenError> {
    todo!()
}
/*
/// エントリ：ASTからRustコードを生成
fn generate_rust_code_(file: &File) -> String {
    let mut out = String::new();
    writeln!(
        &mut out,
        "// @generated by RocketPack rpf codegen\n#![allow(dead_code,unused_imports)]\nuse crate::rocketpack_rpf::runtime as rp;\n"
    )
    .ok();

    // package を module に展開
    let mut depth = 0usize;
    if let Some(pkg) = &file.package {
        for seg in &pkg.value.segments {
            let name = &seg.value;
            writeln!(&mut out, "pub mod {} {{", sanitize_ident(name)).ok();
            depth += 1;
        }
        writeln!(&mut out, "use rp::*;").ok();
    } else {
        writeln!(&mut out, "use rp::*;").ok();
    }

    // 各アイテム
    for it in &file.items {
        match it {
            Item::Struct(s) => {
                write_struct(&mut out, s);
                write_struct_encode_impl(&mut out, s);
                write_struct_decode_impl(&mut out, s);
            }
            Item::Enum(e) => {
                write_enum(&mut out, e);
                write_enum_encode_impl(&mut out, e);
                write_enum_decode_impl(&mut out, e);
            }
            Item::TypeAlias(t) => {
                write_type_alias(&mut out, t);
            }
            Item::Const(c) => {
                write_const(&mut out, c);
            }
        }
        writeln!(&mut out).ok();
    }

    // 閉じモジュール
    for _ in 0..depth {
        writeln!(&mut out, "}}").ok();
    }

    out
}

// ====== struct ======

fn write_struct(buf: &mut String, s: &Struct) {
    writeln!(buf, "#[derive(Debug, Clone, Default, PartialEq)]").ok();
    writeln!(buf, "pub struct {} {{", s.name.value).ok();
    for f in &s.fields {
        let ty = render_type(&f.ty.value);
        writeln!(buf, "  pub {}: {},", sanitize_ident(&f.name.value), ty).ok();
    }
    writeln!(buf, "}}").ok();
}

fn write_struct_encode_impl(buf: &mut String, s: &Struct) {
    writeln!(buf, "impl rp::RpEncode for {} {{", s.name.value).ok();
    writeln!(buf, "  fn encode_into(&self, __buf: &mut Vec<u8>) {{").ok();

    // フィールド番号昇順
    let mut fs = s.fields.clone();
    fs.sort_by_key(|f| f.tag.value);
    for f in fs {
        let tag = f.tag.value;
        let name = sanitize_ident(&f.name.value);
        gen_encode_stmt(buf, "__buf", tag, &format!("self.{}", name), &f.ty.value, 1, None);
    }

    writeln!(buf, "  }}").ok();
    writeln!(buf, "}}").ok();
}

// ====== enum ======

fn write_enum(buf: &mut String, e: &Enum) {
    writeln!(buf, "#[derive(Debug, Clone, PartialEq)]").ok();
    writeln!(buf, "pub enum {} {{", e.name.value).ok();
    for v in &e.variants {
        match &v.kind {
            VariantKind::Unit => {
                writeln!(buf, "  {},", v.name.value).ok();
            }
            VariantKind::Tuple(params) => {
                // Rustのタプルvariantは名前を保持できないため、struct-likeに落とす
                write!(buf, "  {} {{ ", v.name.value).ok();
                for (i, (n, t)) in params.iter().enumerate() {
                    if i > 0 {
                        write!(buf, ", ").ok();
                    }
                    write!(buf, "{}: {}", sanitize_ident(&n.value), render_type(&t.value)).ok();
                }
                writeln!(buf, " }},").ok();
            }
            VariantKind::Record(fields) => {
                write!(buf, "  {} {{ ", v.name.value).ok();
                for (i, f) in fields.iter().enumerate() {
                    if i > 0 {
                        write!(buf, ", ").ok();
                    }
                    write!(buf, "{}: {}", sanitize_ident(&f.name.value), render_type(&f.ty.value)).ok();
                }
                writeln!(buf, " }},").ok();
            }
        }
    }
    writeln!(buf, "}}").ok();
}

fn write_enum_encode_impl(buf: &mut String, e: &Enum) {
    writeln!(buf, "impl rp::RpEncode for {} {{", e.name.value).ok();
    writeln!(buf, "  fn encode_into(&self, __buf: &mut Vec<u8>) {{").ok();
    writeln!(buf, "    match self {{").ok();

    for v in &e.variants {
        let vname = &v.name.value;
        match &v.kind {
            VariantKind::Unit => {
                writeln!(buf, "      Self::{} => {{", vname).ok();
                writeln!(buf, "        rp::write_key(__buf, {}, rp::WT_LEN);", v.tag.value).ok();
                writeln!(buf, "        rp::put_varint_u128(__buf, 0);").ok(); // 空メッセージ
                writeln!(buf, "      }}").ok();
            }
            VariantKind::Tuple(params) => {
                // tupleは @1.. の暗黙タグを振る
                write!(buf, "      Self::{} {{ ", vname).ok();
                for (i, (n, _t)) in params.iter().enumerate() {
                    if i > 0 {
                        write!(buf, ", ").ok();
                    }
                    write!(buf, "{}", sanitize_ident(&n.value)).ok();
                }
                writeln!(buf, " }} => {{").ok();
                writeln!(buf, "        let mut __inner = Vec::new();").ok();
                for (i, (_n, t)) in params.iter().enumerate() {
                    let param_name = sanitize_ident(&_n.value);
                    let tag = (i + 1) as u32;
                    gen_encode_stmt(buf, "__inner", tag, &param_name, &t.value, 3, Some("&".to_string()));
                }
                writeln!(buf, "        rp::write_key(__buf, {}, rp::WT_LEN);", v.tag.value).ok();
                writeln!(buf, "        rp::put_varint_u128(__buf, __inner.len() as u128);").ok();
                writeln!(buf, "        __buf.extend_from_slice(&__inner);").ok();
                writeln!(buf, "      }}").ok();
            }
            VariantKind::Record(fields) => {
                // record内は明示タグを利用
                write!(buf, "      Self::{} {{ ", vname).ok();
                for (i, f) in fields.iter().enumerate() {
                    if i > 0 {
                        write!(buf, ", ").ok();
                    }
                    write!(buf, "{}", sanitize_ident(&f.name.value)).ok();
                }
                writeln!(buf, " }} => {{").ok();
                writeln!(buf, "        let mut __inner = Vec::new();").ok();
                for f in fields {
                    let tag = f.tag.value;
                    let nm = sanitize_ident(&f.name.value);
                    gen_encode_stmt(buf, "__inner", tag, &nm, &f.ty.value, 3, Some("&".to_string()));
                }
                writeln!(buf, "        rp::write_key(__buf, {}, rp::WT_LEN);", v.tag.value).ok();
                writeln!(buf, "        rp::put_varint_u128(__buf, __inner.len() as u128);").ok();
                writeln!(buf, "        __buf.extend_from_slice(&__inner);").ok();
                writeln!(buf, "      }}").ok();
            }
        }
    }

    writeln!(buf, "    }}").ok();
    writeln!(buf, "  }}").ok();
    writeln!(buf, "}}").ok();
}

fn write_struct_decode_impl(buf: &mut String, s: &Struct) {
    writeln!(buf, "impl rp::RpDecode for {} {{", s.name.value).ok();
    writeln!(buf, "  fn decode_from_bytes(__bytes: &[u8]) -> Result<Self, rp::DecodeError> {{").ok();
    writeln!(buf, "    let mut __value = Self::default();").ok();
    writeln!(buf, "    __value.merge_from_bytes(__bytes)?;").ok();
    writeln!(buf, "    Ok(__value)").ok();
    writeln!(buf, "  }}").ok();
    writeln!(buf, "  fn merge_from_bytes(&mut self, __bytes: &[u8]) -> Result<(), rp::DecodeError> {{").ok();
    writeln!(buf, "    let mut __dec = rp::Decoder::new(__bytes);").ok();

    let array_helpers: Vec<(String, String, u64)> = s
        .fields
        .iter()
        .filter_map(|f| {
            if let Type::Array(_, len) = &f.ty.value {
                let field = sanitize_ident(&f.name.value);
                Some((field.clone(), format!("__idx_{}", field), *len))
            } else {
                None
            }
        })
        .collect();

    for (_, idx, _) in &array_helpers {
        writeln!(buf, "    let mut {} = 0usize;", idx).ok();
    }

    writeln!(buf, "    while let Some((__field, __wt)) = __dec.next_field()? {{").ok();
    writeln!(buf, "      match __field {{").ok();

    for field in &s.fields {
        let field_ident = sanitize_ident(&field.name.value);
        let array_info = array_helpers.iter().find(|(name, _, _)| name == &field_ident).map(|(_, idx, len)| (idx.clone(), *len));
        write_struct_field_branch(buf, field, array_info);
    }

    writeln!(buf, "        _ => __dec.skip_field(__wt)?,").ok();
    writeln!(buf, "      }}").ok();
    writeln!(buf, "    }}").ok();
    writeln!(buf, "    Ok(())").ok();
    writeln!(buf, "  }}").ok();
    writeln!(buf, "}}").ok();
}

fn write_struct_field_branch(buf: &mut String, field: &Field, array_info: Option<(String, u64)>) {
    let tag = field.tag.value;
    let field_ident = sanitize_ident(&field.name.value);
    let expected = expected_wire_type(&field.ty.value);
    writeln!(buf, "        {} => {{", tag).ok();
    writeln!(buf, "{}if __wt != {} {{", indent(5), expected).ok();
    writeln!(buf, "{}__dec.skip_field(__wt)?;", indent(6)).ok();
    writeln!(buf, "{}continue;", indent(6)).ok();
    writeln!(buf, "{}{}", indent(5), "}").ok();
    let array_idx = array_info.as_ref().map(|(idx, len)| (idx.as_str(), *len));
    write_field_decode_body(buf, 5, &format!("self.{}", field_ident), &field.ty.value, "__dec", &field_ident, array_idx);
    writeln!(buf, "        }}").ok();
}

fn write_field_decode_body(buf: &mut String, indent_level: usize, target_expr: &str, ty: &Type, decoder_ident: &str, field_ident: &str, array_idx: Option<(&str, u64)>) {
    match ty {
        Type::Option(inner) => match inner.as_ref() {
            Type::Path(_) => {
                let value_var = format!("__value_{}", field_ident);
                write_decode_value(buf, indent_level, &value_var, inner.as_ref(), decoder_ident);
                writeln!(buf, "{}{} = Some({});", indent(indent_level), target_expr, value_var).ok();
            }
            Type::Vec(elem) => {
                let item_var = format!("__item_{}", field_ident);
                write_decode_value(buf, indent_level, &item_var, elem.as_ref(), decoder_ident);
                let pad = indent(indent_level);
                writeln!(buf, "{}if let Some(vec) = {}.as_mut() {{", pad, target_expr).ok();
                writeln!(buf, "{}vec.push({item_var});", indent(indent_level + 1)).ok();
                writeln!(buf, "{}}} else {{", pad).ok();
                writeln!(buf, "{}let mut vec = Vec::new();", indent(indent_level + 1)).ok();
                writeln!(buf, "{}vec.push({item_var});", indent(indent_level + 1)).ok();
                writeln!(buf, "{}{} = Some(vec);", indent(indent_level + 1), target_expr).ok();
                writeln!(buf, "{}}}", pad).ok();
            }
            Type::Map(key_ty, value_ty) => {
                let pad = indent(indent_level);
                writeln!(buf, "{}if {}.is_none() {{", pad, target_expr).ok();
                writeln!(buf, "{}{} = Some(Default::default());", indent(indent_level + 1), target_expr).ok();
                writeln!(buf, "{}}}", pad).ok();
                writeln!(buf, "{}if let Some(map) = {}.as_mut() {{", pad, target_expr).ok();
                write_decode_map_field(buf, indent_level + 1, "map", field_ident, key_ty, value_ty, decoder_ident);
                writeln!(buf, "{}}}", pad).ok();
            }
            Type::Option(_) => {
                writeln!(buf, "{}panic!(\"Option<Option<...>> decoding is not supported\");", indent(indent_level)).ok();
            }
            Type::Array(_, _) => {
                writeln!(buf, "{}panic!(\"Option<[T; N]> decoding is not supported\");", indent(indent_level)).ok();
            }
        },
        Type::Vec(inner) => {
            let value_var = format!("__item_{}", field_ident);
            write_decode_value(buf, indent_level, &value_var, inner.as_ref(), decoder_ident);
            writeln!(buf, "{}{}.push({});", indent(indent_level), target_expr, value_var).ok();
        }
        Type::Array(inner, len) => {
            let (idx_name, _) = array_idx.expect("array index helper not found");
            let value_var = format!("__item_{}", field_ident);
            write_decode_value(buf, indent_level, &value_var, inner.as_ref(), decoder_ident);
            writeln!(buf, "{}if {} < {} {{", indent(indent_level), idx_name, len).ok();
            writeln!(buf, "{}  {}[{}] = {};", indent(indent_level + 1), target_expr, idx_name, value_var).ok();
            writeln!(buf, "{}  {} += 1;", indent(indent_level + 1), idx_name).ok();
            writeln!(buf, "{}{}", indent(indent_level), "}").ok();
        }
        Type::Map(key_ty, value_ty) => {
            write_decode_map_field(buf, indent_level, target_expr, field_ident, key_ty, value_ty, decoder_ident);
        }
        Type::Path(_) => {
            let value_var = format!("__value_{}", field_ident);
            write_decode_value(buf, indent_level, &value_var, ty, decoder_ident);
            writeln!(buf, "{}{} = {};", indent(indent_level), target_expr, value_var).ok();
        }
    }
}

fn write_decode_map_field(buf: &mut String, indent_level: usize, target_expr: &str, field_ident: &str, key_ty: &Type, value_ty: &Type, decoder_ident: &str) {
    let pad = indent(indent_level);
    let key_type = render_type(key_ty);
    let value_type = render_type(value_ty);
    let key_tmp = format!("__key_{}", field_ident);
    writeln!(buf, "{}let __entry_bytes = {}.read_len_bytes()?;", pad, decoder_ident).ok();
    writeln!(buf, "{}let mut __entry_dec = rp::Decoder::new(__entry_bytes);", pad).ok();
    writeln!(buf, "{}let mut __entry_key: Option<{}> = None;", pad, key_type).ok();
    writeln!(buf, "{}let mut __entry_val: {} = Default::default();", pad, value_type).ok();
    writeln!(buf, "{}let mut __entry_has_val = false;", pad).ok();
    let array_idx_name = if matches!(value_ty, Type::Array(_, _)) {
        Some(format!("__entry_idx_{}", field_ident))
    } else {
        None
    };
    if let Some(name) = &array_idx_name {
        writeln!(buf, "{}let mut {} = 0usize;", pad, name).ok();
    }
    writeln!(buf, "{}while let Some((__entry_field, __entry_wt)) = __entry_dec.next_field()? {{", pad).ok();
    writeln!(buf, "{}  match __entry_field {{", pad).ok();

    let key_expected = expected_wire_type(key_ty);
    writeln!(buf, "{}    1 => {{", indent(indent_level + 2)).ok();
    writeln!(buf, "{}if __entry_wt != {} {{", indent(indent_level + 3), key_expected).ok();
    writeln!(buf, "{}__entry_dec.skip_field(__entry_wt)?;", indent(indent_level + 4)).ok();
    writeln!(buf, "{}continue;", indent(indent_level + 4)).ok();
    writeln!(buf, "{}{}", indent(indent_level + 3), "}").ok();
    write_decode_value(buf, indent_level + 3, &key_tmp, key_ty, "__entry_dec");
    writeln!(buf, "{}__entry_key = Some({});", indent(indent_level + 3), key_tmp).ok();
    writeln!(buf, "{}    }}", indent(indent_level + 2)).ok();

    let value_expected = expected_wire_type(value_ty);
    writeln!(buf, "{}    2 => {{", indent(indent_level + 2)).ok();
    writeln!(buf, "{}if __entry_wt != {} {{", indent(indent_level + 3), value_expected).ok();
    writeln!(buf, "{}__entry_dec.skip_field(__entry_wt)?;", indent(indent_level + 4)).ok();
    writeln!(buf, "{}continue;", indent(indent_level + 4)).ok();
    writeln!(buf, "{}{}", indent(indent_level + 3), "}").ok();
    match value_ty {
        Type::Path(_) => {
            let val_tmp = format!("__val_{}", field_ident);
            write_decode_value(buf, indent_level + 3, &val_tmp, value_ty, "__entry_dec");
            writeln!(buf, "{}__entry_val = {val_tmp};", indent(indent_level + 3)).ok();
        }
        Type::Option(inner) => {
            let inner_tmp = format!("__opt_{}", field_ident);
            write_decode_value(buf, indent_level + 3, &inner_tmp, inner.as_ref(), "__entry_dec");
            writeln!(buf, "{}__entry_val = Some({inner_tmp});", indent(indent_level + 3)).ok();
        }
        Type::Vec(inner) => {
            let item_tmp = format!("__item_{}", field_ident);
            write_decode_value(buf, indent_level + 3, &item_tmp, inner.as_ref(), "__entry_dec");
            writeln!(buf, "{}__entry_val.push({item_tmp});", indent(indent_level + 3)).ok();
        }
        Type::Array(inner, len) => {
            let idx_name = array_idx_name.as_ref().expect("array idx exists");
            let item_tmp = format!("__item_{}", field_ident);
            write_decode_value(buf, indent_level + 3, &item_tmp, inner.as_ref(), "__entry_dec");
            writeln!(buf, "{}if {} < {} {{", indent(indent_level + 3), idx_name, len).ok();
            writeln!(buf, "{}  __entry_val[{}] = {item_tmp};", indent(indent_level + 4), idx_name).ok();
            writeln!(buf, "{}  {} += 1;", indent(indent_level + 4), idx_name).ok();
            writeln!(buf, "{}{}", indent(indent_level + 3), "}").ok();
        }
        Type::Map(k, v) => {
            let nested_ident = format!("{}_nested", field_ident);
            write_decode_map_field(buf, indent_level + 3, "__entry_val", &nested_ident, k.as_ref(), v.as_ref(), "__entry_dec");
        }
    }
    writeln!(buf, "{}__entry_has_val = true;", indent(indent_level + 3)).ok();
    writeln!(buf, "{}    }}", indent(indent_level + 2)).ok();

    writeln!(buf, "{}    _ => __entry_dec.skip_field(__entry_wt)?,", indent(indent_level + 2)).ok();
    writeln!(buf, "{}  }}", pad).ok();
    writeln!(buf, "{}{}", pad, "}").ok();
    writeln!(buf, "{}if let Some(__entry_key) = __entry_key {{", pad).ok();
    writeln!(buf, "{}  if __entry_has_val {{", indent(indent_level + 1)).ok();
    writeln!(buf, "{}    {}.insert(__entry_key, __entry_val);", indent(indent_level + 2), target_expr).ok();
    writeln!(buf, "{}  }}", indent(indent_level + 1)).ok();
    writeln!(buf, "{}}}", pad).ok();
}

fn write_decode_value(buf: &mut String, indent_level: usize, value_ident: &str, ty: &Type, decoder_ident: &str) {
    let pad = indent(indent_level);
    match ty {
        Type::Path(p) => {
            if let Some(kind) = builtin_kind(p) {
                match kind {
                    BuiltinKind::Bool => {
                        writeln!(buf, "{pad}let {value_ident} = {decoder_ident}.read_bool()?;").ok();
                    }
                    BuiltinKind::U(bits) => {
                        if bits <= 64 {
                            writeln!(buf, "{pad}let {value_ident} = {decoder_ident}.read_varint_u64()? as u{bits};").ok();
                        } else {
                            writeln!(buf, "{pad}let {value_ident} = {decoder_ident}.read_varint_u128()?;").ok();
                        }
                    }
                    BuiltinKind::I(bits) => {
                        if bits == 128 {
                            writeln!(buf, "{pad}let {value_ident} = {decoder_ident}.read_i128()?;").ok();
                        } else {
                            writeln!(buf, "{pad}let {value_ident} = {decoder_ident}.read_i128()? as i{bits};").ok();
                        }
                    }
                    BuiltinKind::F32 => {
                        writeln!(buf, "{pad}let {value_ident} = {decoder_ident}.read_f32()?;").ok();
                    }
                    BuiltinKind::F64 => {
                        writeln!(buf, "{pad}let {value_ident} = {decoder_ident}.read_f64()?;").ok();
                    }
                    BuiltinKind::String => {
                        writeln!(buf, "{pad}let {value_ident} = {decoder_ident}.read_string()?;").ok();
                    }
                    BuiltinKind::Bytes => {
                        writeln!(buf, "{pad}let {value_ident} = {decoder_ident}.read_bytes_vec()?;").ok();
                    }
                }
            } else {
                let ty_str = render_path_type(p);
                writeln!(buf, "{pad}let {value_ident} = {ty_str}::decode_from_bytes({decoder_ident}.read_len_bytes()?)?;").ok();
            }
        }
        _ => unreachable!("write_decode_value expects a path-like type"),
    }
}

fn write_enum_decode_impl(buf: &mut String, e: &Enum) {
    writeln!(buf, "impl rp::RpDecode for {} {{", e.name.value).ok();
    writeln!(buf, "  fn decode_from_bytes(__bytes: &[u8]) -> Result<Self, rp::DecodeError> {{").ok();
    writeln!(buf, "    let mut __dec = rp::Decoder::new(__bytes);").ok();
    writeln!(buf, "    let mut __result: Option<Self> = None;").ok();
    writeln!(buf, "    while let Some((__field, __wt)) = __dec.next_field()? {{").ok();
    writeln!(buf, "      match __field {{").ok();

    for variant in &e.variants {
        write_enum_variant_branch(buf, e, variant);
    }

    writeln!(buf, "        _ => __dec.skip_field(__wt)?,").ok();
    writeln!(buf, "      }}").ok();
    writeln!(buf, "    }}").ok();
    writeln!(buf, "    match __result {{").ok();
    writeln!(buf, "      Some(v) => Ok(v),").ok();
    writeln!(buf, "      None => Err(rp::DecodeError::Missing(\"{} variant\")),", e.name.value).ok();
    writeln!(buf, "    }}").ok();
    writeln!(buf, "  }}").ok();
    writeln!(buf, "  fn merge_from_bytes(&mut self, __bytes: &[u8]) -> Result<(), rp::DecodeError> {{").ok();
    writeln!(buf, "    *self = Self::decode_from_bytes(__bytes)?;").ok();
    writeln!(buf, "    Ok(())").ok();
    writeln!(buf, "  }}").ok();
    writeln!(buf, "}}").ok();
}

fn write_enum_variant_branch(buf: &mut String, e: &Enum, variant: &Variant) {
    let tag = variant.tag.value;
    let variant_ident = &variant.name.value;
    writeln!(buf, "        {} => {{", tag).ok();
    writeln!(buf, "{}if __wt != rp::WT_LEN {{", indent(5)).ok();
    writeln!(buf, "{}__dec.skip_field(__wt)?;", indent(6)).ok();
    writeln!(buf, "{}continue;", indent(6)).ok();
    writeln!(buf, "{}{}", indent(5), "}").ok();
    writeln!(buf, "{}let __payload = __dec.read_len_bytes()?;", indent(5)).ok();
    match &variant.kind {
        VariantKind::Unit => {
            writeln!(buf, "{}let __value = Self::{};", indent(5), variant_ident).ok();
        }
        VariantKind::Tuple(params) => {
            write_tuple_variant_body(buf, 5, &e.name.value, variant, params);
        }
        VariantKind::Record(fields) => {
            write_record_variant_body(buf, 5, variant, fields);
        }
    }
    writeln!(buf, "{}__result = Some(__value);", indent(5)).ok();
    writeln!(buf, "        }}").ok();
}

fn write_tuple_variant_body(buf: &mut String, indent_level: usize, enum_name: &str, variant: &Variant, params: &[(Spanned<String>, Spanned<Type>)]) {
    let pad = indent(indent_level);
    writeln!(buf, "{}let mut __inner = rp::Decoder::new(__payload);", pad).ok();
    for (name_span, ty_span) in params {
        let name = sanitize_ident(&name_span.value);
        let ty_str = render_type(&ty_span.value);
        writeln!(buf, "{}let mut __opt_{}: Option<{}> = None;", pad, name, ty_str).ok();
    }
    writeln!(buf, "{}while let Some((__inner_field, __inner_wt)) = __inner.next_field()? {{", pad).ok();
    writeln!(buf, "{}  match __inner_field {{", pad).ok();
    for (idx, (name_span, ty_span)) in params.iter().enumerate() {
        let tag = idx + 1;
        let name = sanitize_ident(&name_span.value);
        let expected = expected_wire_type(&ty_span.value);
        writeln!(buf, "{}    {} => {{", indent(indent_level + 2), tag).ok();
        writeln!(buf, "{}if __inner_wt != {} {{", indent(indent_level + 3), expected).ok();
        writeln!(buf, "{}__inner.skip_field(__inner_wt)?;", indent(indent_level + 4)).ok();
        writeln!(buf, "{}continue;", indent(indent_level + 4)).ok();
        writeln!(buf, "{}{}", indent(indent_level + 3), "}").ok();
        let value_var = format!("__value_{}", name);
        write_decode_value(buf, indent_level + 3, &value_var, &ty_span.value, "__inner");
        writeln!(buf, "{}__opt_{} = Some({});", indent(indent_level + 3), name, value_var).ok();
        writeln!(buf, "{}    }}", indent(indent_level + 2)).ok();
    }
    writeln!(buf, "{}    _ => __inner.skip_field(__inner_wt)?,", indent(indent_level + 2)).ok();
    writeln!(buf, "{}  }}", pad).ok();
    writeln!(buf, "{}{}", pad, "}").ok();

    for (name_span, _) in params {
        let name = sanitize_ident(&name_span.value);
        let err_name = format!("{}::{}.{}", enum_name, variant.name.value, name_span.value);
        writeln!(buf, "{}let {} = __opt_{}.ok_or(rp::DecodeError::Missing(\"{}\"))?;", pad, name, name, err_name).ok();
    }

    write!(buf, "{}let __value = Self::{} {{ ", pad, variant.name.value).ok();
    for (idx, (name_span, _)) in params.iter().enumerate() {
        let name = sanitize_ident(&name_span.value);
        if idx > 0 {
            write!(buf, ", ").ok();
        }
        write!(buf, "{}", name).ok();
    }
    writeln!(buf, " }};").ok();
}

fn write_record_variant_body(buf: &mut String, indent_level: usize, variant: &Variant, fields: &[Field]) {
    let pad = indent(indent_level);
    writeln!(buf, "{}let mut __inner = rp::Decoder::new(__payload);", pad).ok();
    let mut array_helpers: Vec<(String, String, u64)> = Vec::new();
    for field in fields {
        let field_ident = sanitize_ident(&field.name.value);
        let ty_str = render_type(&field.ty.value);
        writeln!(buf, "{}let mut {}: {} = Default::default();", pad, field_ident, ty_str).ok();
        if let Type::Array(_, len) = &field.ty.value {
            let idx_name = format!("__idx_{}", field_ident);
            writeln!(buf, "{}let mut {} = 0usize;", pad, idx_name).ok();
            array_helpers.push((field_ident.clone(), idx_name, *len));
        }
    }
    writeln!(buf, "{}while let Some((__inner_field, __inner_wt)) = __inner.next_field()? {{", pad).ok();
    writeln!(buf, "{}  match __inner_field {{", pad).ok();
    for field in fields {
        let field_ident = sanitize_ident(&field.name.value);
        let array_info = array_helpers.iter().find(|(name, _, _)| name == &field_ident).map(|(_, idx, len)| (idx.as_str(), *len));
        write_variant_field_branch(
            buf,
            indent_level,
            field.tag.value,
            &field_ident,
            &field.ty.value,
            "__inner",
            "__inner_wt",
            &field_ident,
            array_info,
        );
    }
    writeln!(buf, "{}    _ => __inner.skip_field(__inner_wt)?,", indent(indent_level + 2)).ok();
    writeln!(buf, "{}  }}", pad).ok();
    writeln!(buf, "{}{}", pad, "}").ok();

    write!(buf, "{}let __value = Self::{} {{ ", pad, variant.name.value).ok();
    for (idx, field) in fields.iter().enumerate() {
        let field_ident = sanitize_ident(&field.name.value);
        if idx > 0 {
            write!(buf, ", ").ok();
        }
        write!(buf, "{}", field_ident).ok();
    }
    writeln!(buf, " }};").ok();
}

fn write_variant_field_branch(
    buf: &mut String,
    indent_level: usize,
    tag: u32,
    field_ident: &str,
    ty: &Type,
    decoder_ident: &str,
    wt_ident: &str,
    target_expr: &str,
    array_idx: Option<(&str, u64)>,
) {
    let expected = expected_wire_type(ty);
    writeln!(buf, "{}{} => {{", indent(indent_level + 2), tag).ok();
    writeln!(buf, "{}if {} != {} {{", indent(indent_level + 3), wt_ident, expected).ok();
    writeln!(buf, "{}{}.skip_field({})?;", indent(indent_level + 4), decoder_ident, wt_ident).ok();
    writeln!(buf, "{}continue;", indent(indent_level + 4)).ok();
    writeln!(buf, "{}{}", indent(indent_level + 3), "}").ok();
    write_field_decode_body(buf, indent_level + 3, target_expr, ty, decoder_ident, field_ident, array_idx);
    writeln!(buf, "{}{}", indent(indent_level + 2), "}").ok();
}

fn expected_wire_type(ty: &Type) -> &'static str {
    match ty {
        Type::Option(inner) | Type::Vec(inner) | Type::Array(inner, _) => expected_wire_type(inner),
        Type::Map(_, _) => "rp::WT_LEN",
        Type::Path(p) => {
            if let Some(kind) = builtin_kind(p) {
                match kind {
                    BuiltinKind::Bool | BuiltinKind::U(_) | BuiltinKind::I(_) => "rp::WT_VARINT",
                    BuiltinKind::F32 => "rp::WT_32",
                    BuiltinKind::F64 => "rp::WT_64",
                    BuiltinKind::String | BuiltinKind::Bytes => "rp::WT_LEN",
                }
            } else {
                "rp::WT_LEN"
            }
        }
    }
}

fn indent(level: usize) -> String {
    "  ".repeat(level)
}

// ====== type / const ======

fn write_type_alias(buf: &mut String, t: &TypeAlias) {
    writeln!(buf, "pub type {} = {};", t.name.value, render_type(&t.ty.value)).ok();
}

fn write_const(buf: &mut String, c: &Const) {
    writeln!(buf, "pub const {}: {} = {};", c.name.value, render_type(&c.ty.value), render_literal(&c.value.value)).ok();
}

// ====== encode ステートメント生成 ======

fn gen_encode_stmt(
    buf: &mut String,
    dst: &str,
    tag: u32,
    expr: &str,
    ty: &Type,
    indent: usize,
    // for enum/record inner where we already have bindings by ref
    force_by_ref: Option<String>,
) {
    let pad = "  ".repeat(indent);
    match ty {
        Type::Option(inner) => {
            writeln!(buf, "{pad}if let Some(ref __v) = {expr} {{").ok();
            gen_encode_stmt(buf, dst, tag, "__v", inner, indent + 1, Some("&".to_string()));
            writeln!(buf, "{pad}}}").ok();
        }
        Type::Vec(inner) => {
            writeln!(buf, "{pad}for __it in {expr}.iter() {{").ok();
            gen_encode_stmt(buf, dst, tag, "__it", inner, indent + 1, Some("&".to_string()));
            writeln!(buf, "{pad}}}").ok();
        }
        Type::Array(inner, _n) => {
            writeln!(buf, "{pad}for __it in {expr}.iter() {{").ok();
            gen_encode_stmt(buf, dst, tag, "__it", inner, indent + 1, Some("&".to_string()));
            writeln!(buf, "{pad}}}").ok();
        }
        Type::Map(k, v) => {
            writeln!(buf, "{pad}for (__k, __v) in {expr}.iter() {{").ok();
            writeln!(buf, "{pad}  let mut __entry = Vec::new();").ok();
            // key -> @1
            gen_encode_stmt(buf, "__entry", 1, "__k", k, indent + 1, Some("&".to_string()));
            // value -> @2
            gen_encode_stmt(buf, "__entry", 2, "__v", v, indent + 1, Some("&".to_string()));
            writeln!(buf, "{pad}  rp::write_key({dst}, {tag}, rp::WT_LEN);").ok();
            writeln!(buf, "{pad}  rp::put_varint_u128({dst}, __entry.len() as u128);").ok();
            writeln!(buf, "{pad}  {dst}.extend_from_slice(&__entry);").ok();
            writeln!(buf, "{pad}}}").ok();
        }
        Type::Path(p) => {
            if let Some(k) = builtin_kind(p) {
                match k {
                    BuiltinKind::Bool => {
                        writeln!(buf, "{pad}rp::write_key({dst}, {tag}, rp::WT_VARINT);").ok();
                        if force_by_ref.is_some() {
                            writeln!(buf, "{pad}rp::put_varint_u64({dst}, if *{expr} {{1}} else {{0}});").ok();
                        } else {
                            writeln!(buf, "{pad}rp::put_varint_u64({dst}, if {expr} {{1}} else {{0}});").ok();
                        }
                    }
                    BuiltinKind::U(nbits) => {
                        writeln!(buf, "{pad}rp::write_key({dst}, {tag}, rp::WT_VARINT);").ok();
                        if nbits <= 64 {
                            if force_by_ref.is_some() {
                                writeln!(buf, "{pad}rp::put_varint_u64({dst}, *{expr} as u64);").ok();
                            } else {
                                writeln!(buf, "{pad}rp::put_varint_u64({dst}, {expr} as u64);").ok();
                            }
                        } else {
                            if force_by_ref.is_some() {
                                writeln!(buf, "{pad}rp::put_varint_u128({dst}, *{expr} as u128);").ok();
                            } else {
                                writeln!(buf, "{pad}rp::put_varint_u128({dst}, {expr} as u128);").ok();
                            }
                        }
                    }
                    BuiltinKind::I(_nbits) => {
                        writeln!(buf, "{pad}rp::write_key({dst}, {tag}, rp::WT_VARINT);").ok();
                        if force_by_ref.is_some() {
                            writeln!(buf, "{pad}let __zz = rp::zigzag_i128(*{expr} as i128);").ok();
                        } else {
                            writeln!(buf, "{pad}let __zz = rp::zigzag_i128({expr} as i128);").ok();
                        }
                        writeln!(buf, "{pad}rp::put_varint_u128({dst}, __zz);").ok();
                    }
                    BuiltinKind::F32 => {
                        writeln!(buf, "{pad}rp::write_key({dst}, {tag}, rp::WT_32);").ok();
                        if force_by_ref.is_some() {
                            writeln!(buf, "{pad}{dst}.extend_from_slice(&(*{expr}).to_le_bytes());").ok();
                        } else {
                            writeln!(buf, "{pad}{dst}.extend_from_slice(&({expr}).to_le_bytes());").ok();
                        }
                    }
                    BuiltinKind::F64 => {
                        writeln!(buf, "{pad}rp::write_key({dst}, {tag}, rp::WT_64);").ok();
                        if force_by_ref.is_some() {
                            writeln!(buf, "{pad}{dst}.extend_from_slice(&(*{expr}).to_le_bytes());").ok();
                        } else {
                            writeln!(buf, "{pad}{dst}.extend_from_slice(&({expr}).to_le_bytes());").ok();
                        }
                    }
                    BuiltinKind::String => {
                        writeln!(buf, "{pad}rp::write_key({dst}, {tag}, rp::WT_LEN);").ok();
                        if force_by_ref.is_some() {
                            writeln!(buf, "{pad}let __b = (*{expr}).as_bytes();").ok();
                        } else {
                            writeln!(buf, "{pad}let __b = ({expr}).as_bytes();").ok();
                        }
                        writeln!(buf, "{pad}rp::write_len_delimited({dst}, __b);").ok();
                    }
                    BuiltinKind::Bytes => {
                        writeln!(buf, "{pad}rp::write_key({dst}, {tag}, rp::WT_LEN);").ok();
                        if force_by_ref.is_some() {
                            writeln!(buf, "{pad}rp::write_len_delimited({dst}, &*{expr});").ok();
                        } else {
                            writeln!(buf, "{pad}rp::write_len_delimited({dst}, &{expr});").ok();
                        }
                    }
                }
            } else {
                // message (struct/enum)
                writeln!(buf, "{pad}let mut __tmp = Vec::new();").ok();
                if force_by_ref.is_some() {
                    writeln!(buf, "{pad}{expr}.encode_into(&mut __tmp);").ok();
                } else {
                    writeln!(buf, "{pad}{expr}.encode_into(&mut __tmp);").ok();
                }
                writeln!(buf, "{pad}rp::write_key({dst}, {tag}, rp::WT_LEN);").ok();
                writeln!(buf, "{pad}rp::put_varint_u128({dst}, __tmp.len() as u128);").ok();
                writeln!(buf, "{pad}{dst}.extend_from_slice(&__tmp);").ok();
            }
        }
    }
}

// ====== 型/リテラルのレンダリング ======

fn render_type(t: &Type) -> String {
    match t {
        Type::Path(p) => render_path_type(p),
        Type::Option(inner) => format!("Option<{}>", render_type(inner)),
        Type::Vec(inner) => format!("Vec<{}>", render_type(inner)),
        Type::Map(k, v) => format!("std::collections::BTreeMap<{}, {}>", render_type(k), render_type(v)),
        Type::Array(inner, n) => format!("[{}; {}]", render_type(inner), n),
    }
}

fn render_path_type(p: &Path) -> String {
    if let Some(k) = builtin_kind(p) {
        match k {
            BuiltinKind::Bool => "bool".into(),
            BuiltinKind::U(bits) => format!("u{bits}"),
            BuiltinKind::I(bits) => format!("i{bits}"),
            BuiltinKind::F32 => "f32".into(),
            BuiltinKind::F64 => "f64".into(),
            BuiltinKind::String => "String".into(),
            BuiltinKind::Bytes => "Vec<u8>".into(),
        }
    } else {
        let segs: Vec<String> = p.segments.iter().map(|s| sanitize_ident(&s.value)).collect();
        segs.join("::")
    }
}

fn render_literal(l: &Literal) -> String {
    match l {
        Literal::Bool(b) => format!("{}", b),
        Literal::Int(n) => format!("{}", n),
        Literal::Float(f) => format!("{}", f),
        Literal::String(s) => format!("{:?}", s), // Rustの文字列リテラルとしてエスケープ
        Literal::Bytes(bytes) => render_bytes_literal(bytes),
    }
}

fn render_bytes_literal(bytes: &[u8]) -> String {
    if bytes.is_empty() {
        "Vec::<u8>::new()".into()
    } else {
        let inner = bytes.iter().map(|b| b.to_string()).collect::<Vec<_>>().join(", ");
        format!("vec![{}]", inner)
    }
}

#[derive(Copy, Clone)]
enum BuiltinKind {
    Bool,
    U(u32),
    I(u32),
    F32,
    F64,
    String,
    Bytes,
}

fn builtin_kind(p: &Path) -> Option<BuiltinKind> {
    if p.segments.len() != 1 {
        return None;
    }
    let s = p.segments[0].value.as_str();
    Some(match s {
        "bool" => BuiltinKind::Bool,
        "u8" => BuiltinKind::U(8),
        "u16" => BuiltinKind::U(16),
        "u32" => BuiltinKind::U(32),
        "u64" => BuiltinKind::U(64),
        "u128" => BuiltinKind::U(128),
        "i8" => BuiltinKind::I(8),
        "i16" => BuiltinKind::I(16),
        "i32" => BuiltinKind::I(32),
        "i64" => BuiltinKind::I(64),
        "i128" => BuiltinKind::I(128),
        "f32" => BuiltinKind::F32,
        "f64" => BuiltinKind::F64,
        "string" => BuiltinKind::String,
        "bytes" => BuiltinKind::Bytes,
        _ => return None,
    })
}

fn sanitize_ident(s: &str) -> String {
    // ざっくり：キーワード衝突を避けたい時は末尾に '_' を付与
    match s {
        "type" | "const" | "struct" | "enum" | "fn" | "mod" | "use" | "crate" | "super" | "self" | "match" | "loop" | "for" | "while" | "in" | "where" | "impl" | "trait"
        | "move" | "async" | "await" | "ref" | "mut" | "pub" | "let" | "break" | "continue" | "return" => format!("{}_", s),
        _ => s.to_string(),
    }
}

#[cfg(test)]
mod tests {
    #[allow(unused)]
    use super::*;

    #[test]
    fn codegen_test() {}
}
*/
